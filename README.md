# Ergodic Search

This repository implements basic ergodic search as outlined in [[1]](#1) and modified from MO-ES [[2]](#2).
This optimization strategy learns control parameters (translational and angular velocities) that minimize
the ergodic metric, in addition to other loss components.
In addition to performing trajectory optimization over single maps in a static manner, the planner
class is also capable of handling updates to the map and re-planning based on prior controls. The package 
also allows for external provision of dynamics models for use in the 
optimization step.

## Table of Contents

- [Dependencies](#dependencies)
- [Installation](#how-to-install)
- [Usage](#how-to-use)
    - [ErgPlanner](#the-ergplanner-class)
    - [ErgLoss](#the-ergloss-class)
    - [Examples](#examples)
    - [Custom Dynamics](#incorporating-dynamics-models)
- [References](#references)

## Dependencies

This implementation is built in Python and relies on PyTorch for optimization. The versions listed
below are the latest versions on which the code has been tested. The code is capable of running on 
a CPU or GPU.
- Python >= 3.8.10
- PyTorch >= 2.0.1
- argparse >= 1.1
- matplotlib >= 3.7.1
- functools

If this code is being run on a GPU, CUDA must additionally be installed per the specifications for 
the GPU and the version of PyTorch being used. The code was tested on a [GPU INFO] GPU with CUDA 12.4.

## How to Install

Once the dependencies have been installed, clone this repository and navigate into it:
```
git clone git@github.com:PlanetaryRobotics/ergodic-search
cd ergodic-search
```

Then the package can be locally installed with ```pip install -e .```

## How to Use

This section provides more details on how this repository can be used to perform ergodic search on 
custom maps with various parameter settings. Two example scripts are provided in the top level directory. 

### The ErgPlanner Class

The ergodic planner provided in this repository is contained in the ```ErgPlanner``` class. A set of command line
arguments from ```argparse``` is the only required parameter for initializing the planner. Although this class 
can be initialized without a map, it will require a map to be provided to actually perform ergodic search, which 
can be done with the ```update_pdf``` method. 

#### Class Methods

##### ```__init__```

Initializes the class. This method requires command line arguments provided from the ```ErgArgs``` class via the ```args``` parameter.
Optional arguments are the map (```pdf```), initial controls (```init_controls```), dynamics module (```dyn_model```), and frequency 
information (```fourier_freqs```, ```freq_wts```).

If no initial controls are provided, the controls are initialized to all 0s. If no dynamics module is provided, the differential drive 
dynamics module defined in ```ergodic_search.dynamics``` is used. If no frequency information is provided, the ```num_freqs``` parameter in ```args``` must be > 0.

##### ```update_pdf```

Updates the stored map. This method requires a new map to be provided via the ```pdf``` parameter and does not return any
values. Additional optional parameters are ```fourier_freqs``` and ```freq_wts``` to provide the frequencies and weights to 
use with the new map when computing the ergodic metric. These parameters both default to None.

##### ```update_controls```

Updates the stored controls. This method requires a new set of controls to be provided via the ```controls``` parameter and 
does not return any values.

##### ```compute_traj```

Performs the trajectory optimization using ergodic search based on the stored controls, map, and dynamics module. This method
takes one optional argument ```debug``` which is set to False by default and returns the optimized controls, trajectory, and
the final loss metric.

##### ```visualize```

Displays the results from performing ergodic search. The results for the examples shown below are created using this method.
The top left displays the original map, the bottom left displays the map reconstruction from the map statistics, the bottom right
displays the map reconstruction from the trajectory statistics, and the top right displays the difference between the 
reconstructions (bottom left - bottom right). All maps also display the planned trajectory. This method takes no arguments and 
does not return any values.


#### Command Line Arguments

The ```ErgPlanner``` class supports a number of command line arguments that provide flexibility
when using this planner. These arguments are generated by initializing an instance of the ```ErgArgs``` 
class at the beginning of a script and can be modified as desired within a script. The lists below
review the available arguments:

**Search Parameters**

| Parameter | Type | Default | Description |
| ----- | ----- | ----- | ----- |
| ```num_pixels``` | int | 500 | Number of pixels along one side of the map |
| ```traj_steps``` | int | 100 | Number of steps in the trajectory |
| ```start_pose``` | float(3) | [0,0,0] | Starting position (x, y, theta) |
| ```end_pose``` | float(3) | [0,0,0] | Ending position (x, y, theta) |

**Optimization Parameters**

| Parameter | Type | Default | Description |
| ----- | ----- | ----- | ----- |
| ```learn_rate``` | float | 0.001 | Learning rate for optimizer |
| ```iters``` | int | 1000 | Maximum number of iterations for optimization |
| ```epsilon``` | float | 0.005 | Threshold for loss metric (optimization stops if loss is lower than this) |
| ```num_freqs``` | int | 0 | Number of frequencies to use. If 0, expects frequencies to be provided in ```fourier_freqs``` |


**Loss Weights**

| Parameter | Type | Default | Description |
| ----- | ----- | ----- | ----- |
| ```erg_wt``` | float | 1 | Weight on ergodic metric component of loss |
| ```transl_vel_wt``` | float | 0.1 | Weight on translational velocity component of loss |
| ```ang_vel_wt``` | float | 0.05 | Weight on angular velocity component of loss |
| ```bound_wt``` | float | 100 | Weight on boundary component of loss |
| ```end_pose_wt``` | float | 0.5 | Weight on end position component of loss |

**Flags**

| Parameter | Description |
| ----- | ----- |
| ```gpu``` | Use the GPU instead of CPU |
| ```debug``` | Print loss components for debugging |


### The ErgLoss Class

The ergodic loss used for trajectory optimization is defined in ```ergodic_search.erg_metric``` and implemented
as the ```ErgLoss``` class. This class is a PyTorch module and implements discrete ergodic metric computations based on 
either the provided frequencies or number of frequencies. In addition, the loss includes components associated with the
trajectory going out of bounds, the end point, and the maximum translational and angular velocities. The full loss function
is
```math
\mathcal{L} = w_{erg}\left(\sum_k \Lambda_k (\phi_k - c_k(\xi))^2 \right) + w_{transl}\frac{\sum v_{transl}^2}{T} + w_{ang} \frac{\sum v_{ang}^2}{T} + w_{end} \sum(\xi_T - end)^2 + w_{bound}\mathcal{L}_{bound}
```

#### Ergodic Metric

The first term in the equation above is the ergodic metric, which computes the difference between Fourier components associated
with the map ($\phi_k$) and the trajectory ($c_k(\xi)$, where $\xi$ is the trajectory). The Fourier components are defined based on a set of frequencies $\omega$ indexed by a 2D index $k$, either provided via ```fourier_freqs``` to the planner and loss classes or set to integers between 0 and ```args.num_freqs```. The $\Lambda$ 
values are weights associated with each frequency, either provided via ```freq_wts``` or defined as $\Lambda_k = \frac{1}{(1+||k||^2)^s}$ where $s = 2$ based on practical performance of the algorithm.

The discrete Fourier components are computed using Fourier basis functions $F_k(\mathbb{x}) = \frac{1}{h_k}cos(\omega_k \pi \mathbb{x}_1)cos(\omega_k \pi \mathbb{x}_2)$ as

$$\phi_k = \sum_X \phi(\mathbb{x})F_k(\mathbb{x})$$

$$c_k = \frac{1}{T} \sum_t F_k(\xi(t))$$

for a set of grid points defined across the map domain. The $h_k$ normalizing factors in the Fourier components are computed as 

$$h_k =  \left(\prod_i \frac{2k_i + \sin (2k_i)}{4k_i}\right)^{1/2}$$

#### Additional Loss Components

The second and third terms compute losses associated with the translational and angular velocities, respectively. Both of these are
defined as the average squared velocity across the set of controls. However, the terms have been separated to allow for application 
of different weights to each terms.

The fourth term computes a loss associated with the final position in the trajectory, which should be close to the desired end position.
This is defined as the squared Euclidean distance between the desired end position and the actual end position.

The final term computes a loss associated with the trajectory passing outside of the bounds of the map. This is set to the distance 
to the boundary for trajectory points outside of the bounds and 0 for points inside the bounds, summed across the entire trajectory. 
The weight on this component is generally set very high compared to the other loss terms to ensure the trajectory remains in the map.

#### Class Methods

##### ```__init__```

Initializes the class based on a set of command line arguments ```args``` and a dynamics module ```dyn_model```. Additional optional
arguments include the map (```pdf```) and the frequency information (```fourier_freqs``` and ```freq_wts```).

##### ```forward```

Computes the loss associated with a set of controls provided via the ```controls``` argument. This involves calling the dynamics
module to produce a trajectory. This trajectory and the controls are then used to compute the full loss, with the components weighted
according to the weights provided in the command line arguments. The full loss is returned. One optional parameter, ```print_flag```, allows printing all of the loss components for each iteration and can be useful for debugging (the ```debug``` command line argument sets this to True).

##### ```calc_erg_metric```

Computes the ergodic metric associated with a set of controls provided via the ```controls``` argument. This involves calling the 
dynamics module to produce a trajectory. The ergodic metric is returned.

##### ```update_pdf```

Updates the stored map. This method requires a new map to be provided via the ```pdf``` parameter and does not return any
values. Additional optional parameters are ```fourier_freqs``` and ```freq_wts``` to provide the frequencies and weights to 
use with the new map when computing the ergodic metric. These parameters both default to None. After the map has been updated, the 
ergodic loss calculations are re-initialized using ```set_up_calcs```.

##### ```set_up_calcs```

Sets up the calculations for the ergodic metric and is called when a map is provided to the class, either via the 
```__init__``` method or via ```update_pdf```. This includes setting up the frequencies, weights, and normalizing factors, as well as 
pre-computing the map statistics and associated reconstruction. The method does not take any parameters and does not return any value.

##### ```ck```

Computes the trajectory statistics for the trajectory provided via the ```traj``` argument. This method returns the trajectory
statistics $c_k$ using the stored frequency information and normalizing factors.

##### ```traj_recon```

Computes a reconstruction of the map from trajectory statistics using the trajectory provided via the ```traj``` argument.
The map reconstruction is returned as a flat array that can be reshaped to the original 2D map using the number of pixels as ```recon.reshape((args.num_pixels, args.num_pixels))```


### Examples

The first script, ```example.py```, provides a simple example of 
ergodic search on a map with two , using the default differential drive dynamics module. Running
```python3 example.py``` should produce the following visualization:

![Static Example](images/example.png)

The second script, ```example_updates.py```, provides a simple example in which the map is updated after each step of the planner.
The trajectory is then re-planned. This script can be used to see how the map and controls updates work. The initial results should look identical to the first example; the results after 5 and 10 updates are shown below:

[ADD IMAGE]

An example script is included in ```example.py``` for reference. This script enables the user to 
adjust parameters but uses the same underlying map. Reviewing the script can help see how the ```ErgPlanner```
class can be used in practice.


### Incorporating Dynamics Models

A differential drive dynamics class (```DiffDrive```) is provided in ```ergodic_search.dynamics``` and is used for both examples.
Separate dynamics modules can be provided to the planner on initialization via the ```dyn_model``` parameter. User-defined
dynamics modules should be implemented as a PyTorch module with a ```forward``` method. This method should compute a trajectory based on the controls stored in this module, which are the parameters being optimized by PyTorch.


## References

<a name="1"></a>[1] G. Mathew and I. Mezić, "Metrics for ergodicity and design of ergodic dynamics for multi-agent systems," Physica D: Nonlinear Phenomena, vol. 240, no. 4-5, pp. 432-442, Feb. 2011, doi: [10.1016/j.physd.2010.10.010](https://www.sciencedirect.com/science/article/pii/S016727891000285X).


<a name="2"></a>[2] Z. Ren et al., "A Local Optimization Framework for Multi-Objective Ergodic Search," Proceedings of Robotics: Science and Systems, New York City, NY, USA, June 2022. Code available in the [rap-lab-org/public_moes](https://github.com/rap-lab-org/public_moes) repository.
